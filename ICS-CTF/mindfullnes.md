crypto challenge this is the solution script:

```python
>>> from Crypto.Util.number import long_to_bytes
>>> from sympy import totient
>>> 
>>> # Provided values from output.txt
>>> c = 1090697257161681827338467372494237015524155841340205972141075438006486846235352812783606709214148871185568742706572950302594682835091151613629583124470212
>>> c2 = 254391028077209233778759407947580279766624925013148195405838567802963251650405824372167315686002423861653478378132209734315668081970848294918787786495188987547812091434944178085085757595624064225009824928811721516203729027779235065417115161570075383463691505393393959811765317158139578761677959060169156201847598
>>> d2 = 254190669315237659611656690873708283358313610476086281934479967762596603847181139118237009352408165213690516418963820794025807833788636490463597342510978964539012058693650957672644126092209239984585008351285329298831383304909055869506337791818181897336451413249560522009872200579635743470347341120977330484037546
>>> n = 12772669759377422294285933457739305980370839455903351269835559814487644603035708044745452752384246167635593205134222890220262680226322097808123273638439889
>>> part2 = 3036467688395429171878582378698544047639776291041683854137816180801927641124603773
>>> 
>>> # Step 1: Recover real c and d
>>> real_c = c2 // 2 % n
>>> real_d = d2 // 2
>>> 
>>> # Step 2: Decrypt m
>>> m = pow(real_c, real_d, n)
>>> flag_part1 = long_to_bytes(m)
>>> 
>>> # Step 3: Fast waiting(m) using Eulerâ€™s Totient Function
>>> curseed = totient(m)
>>> 
>>> # Step 4: Recover second half of the flag
>>> flag_part2 = long_to_bytes(part2 ^ curseed)
>>> 
>>> # Step 5: Combine and print
>>> full_flag = flag_part1 + flag_part2
>>> print(full_flag.decode())
prelim{just_a_warm_up_for_u_lets_finish_the_next_challs}
```